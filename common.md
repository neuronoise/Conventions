## Общие рекомендации по написанию кода
#### Использование стандартов
Новые стандарты C++ дают инструменты и возможности, которые сильно упрощают и улучшают производительность как программиста, так и получаемого программного обеспечения. На данный момент стандарт **C++11** уже можно считать необходимой базой для написания качественного и современного кода. Если имеется возможность применять более поздние стандарты, рекомомендуется так и поступать - как минимум, время устаревания такого кода будет гораздо больше, а его возможности шире; при этом эффективность тоже возрастёт.

#### Принцип разработки
Чем более сложным и объёмным получается код, тем легче в нём запутаться и совершить ошибку. Поэтому в разработке рекомендуется следовать принципу **KISS** (**K**eep **I**t **S**hort and **S**imple). 
Функция должна выполнять одну задачу и иметь обозримый размер (обычно 1-2 экрана, не более) - если это не так, стоит задуматься над переработкой кода. Аналогично с классами: они должны иметь высокую связность (cohesion), а не превращаться в "швейцарский нож".

Не стоит складывать несколько классов в один файл - лучше, чтобы каждый самостоятельный класс находился в отдельном файле. Допустимо иметь небольшой вспомогательный класс в файле основного, если он используется только в локальном контексте (и нигде больше!).

#### Флаги компиляции
Часто встречается ситуация, когда в проекте игнорируются предупреждения компилятора. Фактически, это заложенная "бомба замедленного действия": каждое предупреждение компилятора - это потенциальная ошибка, возможно даже критическая! И если уж даже компилятор предупреждает о вероятной ошибке, на это точно нужно обращать внимание. 

По этой причине в скрипты системы сборки обязательно должны быть включены флаги (для gcc, или аналоги для других компиляторов):
- ```-Werror``` - превращает предупреждения компилятора в ошибки
- ```-Wall``` - все основные проверки
- ```-Wextra``` дополнительные проверки
- ```-Wpedantic``` - проверки на строгое соблюдение стандартов языка

Если в проекте есть внешние библиотеки, которые вызывают предупреждения, стоит настроить скрипты сборки так, чтобы они подавлялись конкретно для данных библиотек.

О флагах компиляции, связанных с предупреждениями, подробнее [тут](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html).

#### Использование include guard
Использование конструкции защиты от повторного включения обязательно для проектов, в которых больше одного заголовочного файла ```*.h``` (то есть, практически для всех). Единственным слабым местом конструкции является уникальность идентификатора макроса. 

Рекомендуется использовать следующее правило для формарования идентификатора: имя файла в верхнем регистре, знак подчерка ```_```, литера ```H```. В случае, если существует вероятность повторения имён файлов в проекте (чего лучше всё же избегать), идентификатор снабжается суффиксом: знак подчерка ```_``` и случайное значение какой-либо хэш-функции. Это делает вероятнось коллизий по идентификатору исчезающе маленькой.
```c++
#ifndef SOMECLASS_H_B8F55CA7
#define SOMECLASS_H_B8F55CA7
 
class SomeClass
{
    int m_member;
};

#endif // SOMECLASS_H_B8F55CA7
```
#### Ограничение области видимости
Крайне рекомендуется использование пространств имён (```namespace```) для разграничения областей видимости внутри проекта. Таким образом происходит организация кода в виде логических групп, а также уменьшается вероятнось конфликта имен, которые могут возникнуть, особенно в таких случаях, когда проект включает несколько библиотек. Также можно использовать анонимное пространство имён, чтобы ограничить область видимости текущей единицей трансляции.

Запрещается использовать директиву ```using namespace ...``` в глобальном контексте! Это делает использование пространст имён совершенно бессмыленным. При использовании директиву нужно ограничить минимально возможной областью - только там, где это необходимо.

Если по какой-то причине возникла необходимость в использовании глобальных переменных, их нужно заключить в пространство имён ```globals```. Это позволит избежать потенциальных ошибок по причине скрытия.

Для классов рекомендуется минимизировать явный (**public**) интерфейс. Пользователь класса не должен изменять извне внутренние переменные и состояния - это нарушает принцип инкапсуляции.

#### Спецификаторы
Использование спецификаторов помогает как избежать неявных ошибок, так и оптимизировать код. Рекомендуется добавление соответствующих спецификаторов там, где это необходимо:
- ```const``` - для постянных величин и методов, которые не меняют значений в текущей области видимости
- ```constexpr``` - для значений, функций и конструкторов, возвращающих неизменяемое значение тривиального типа
- ```explicit``` - для классов, если они не должны иметь возможность неявного преобразования к другим типам
- ```inline``` - для коротких функций и методов, уменьшает количество копий при компиляции

#### Магические числа
Константные числовые значения в коде с неочевидным смыслом ("магические числа") - крайне вредная практика. Читаемость кода мгновенно становится очень низкой, а сами такие числа - потенциальный источник ошибок. По возможности, все числовые значения должны быть либо вычислены с учётом контекста, либо обозначены как переменная с описательным названием и спецификатором ```const```. 
```
using IntPair = std::pair<int,int>;
void drawWindow(const IntPair& p1, const IntPair& p2)
{
    // тут рисуем окно
}
...

// плохо: что происходит?
drawWindow({0,0},{640,480});

// хорошо: рисуем окно по размерам экрана!
const IntPair screenTopLeft = {0,0};
const IntPair screenSize = {640,480};
drawWindow(screenTopLeft,screenSize);
```
#### Документирование
Документирование кода является важной составляющей разработки программного обеспечения. Грамотно задокументированный код требует кратно меньше времени для понимания и повторного использования; не нужно судорожно вспоминать "а что делает функция f()" или "как работает класс A", лезть в реализацию в попытках узнать назначение, объяснять коллегам "а зачем нам эта штука", и пр. Документация позволяет проще вести учёт готового функционала и избегать повторной реализации уже существующего. 

Документирующий блок - особым образом оформленный комментарий. Для документирования рекомендуется использовать систему **doxygen** - её используют, например, в библиотеках **STL** и **Boost**. Подробнее о принципах и использовании [здесь](documenting.md).

Большинство современных сред для разработки умеют выводить документирующий блок при наведении курсора на интересующую часть кода, что потенциально может ускорить разработку. Процесс документирования занимает относительно малое время, но при этом способен сэкономить значительно больше - особенно в крупных и долгосрочных проектах с большой командой разработчиков.

Важно при внесении изменений в программный код не забывать обновлять документацию. Устаревшая документация даже хуже, чем её отсутствие - это потенциальный источник большого количества ошибок.

#### Использование комментариев
В процессе работы могут появляться комментарии, которые описывают будущий алгоритм или недостающую часть, а также куски закомментированного старого кода. Эти комментарии по завершению работы теряют актуальность и будут только засорять содержимое файлов. Подобным вещам точно не место в финальном коде, поэтому не стоит забывать "прибирать за собой".

В целом, хорошо написанный и задокументированный код в комментариях уже не нуждается. Необходимость пояснения с помощью комментария - возможный индикатор кода, требующего рефакторинга. Но есть некоторые моменты, в которых комментарии могут быть уместны.
- **Юридическая информация.** Информация о разработчике, версии кода, лицензии. Обычно этот блок помещается в начале файла.
- **Сложный код**. Если в коде необходимо использовать математические формулы, какую-то сложную конструкцию или хитрый алгоритм - можно снабдить это место кратким комментарием, поясняющим ситуацию. Но это не должен быть комментарий, объясняющий плохо написанный код.
- **Этапность**. Бывают функции, в которых выполняются несколько взаимосвязанных этапов, следующих в определенном порядке, разделять которые было бы нежелательно. В таком случае можно обозначить этапы предваряющими комментариями, чтобы быстро ориентироваться в них.
- **Компромисс**. Иногда возникает ситуция, когда приходится идти на компромисс и добавлять в код "костыль" (обход сложной ситуации) - например, если нужно обойти ошибку в используемой версии сторонней библиотеки. Такое место стоит отметить комментарием с пояснением, почему этот код существует, чтобы в будущем по возможности вернуться и исправить его.

[< вернуться к списку разделов](README.md#Разделы)
